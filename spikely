#!/usr/bin/perl
use strict;
use warnings;

use Getopt::Long;
use Math::Random::Discrete;
use YAML qw(LoadFile);
use Carp;

#-----------------------------------------------------------------------------
#----------------------------------- MAIN ------------------------------------
#-----------------------------------------------------------------------------

my $usage = "

Synopsis:

# Get this usage statement (note this is a function not an option).
spikely help

# Get usage statement for a particular function.
spikely cohort --help

# Run cohort spiking mode with parameters defined in a config file.
spikely cohort --config_file spikely.yaml --disease_vcf clinvar.vcf.gz \
    --sample_vcf case_control.vcf.gz

# Run trio spiking mode with parameters on the command line.
# NOTE: trio spiking not yet implimented.
spikely trio --ped family.ped --inheritance recessive --maf_key MAF \
    disease_alleles.vcf.gz

Description:

This script will consume a VCF file of causal variants and produce a
VCF file with those variants 'spiked' into the genotypes of a set of
individuals defined by various genetic and population parameters.  The
script has several modes of operation corresponding to various NGS
genetic analysis designs (i.e. trio, pedigree, cohort etc.).  It
understands genetic concepts such as inheritance, penetrance and
population attributable risk and allele population frequency and
allows those parameters to be specified in a configuration file.  the
VCF file of affected cases.  Note that currently only cohort spiking
is implimented.

Functions:

help
duo
trio
quartet1
quartet2
pedigree
cohort

";

my $function = shift @ARGV;

if (! $function) {
    my $cmd_ln = $0 . join(' ', '', @ARGV);
    warn "$usage\n\n";
    send_message('FATAL',
		 'must_specify_function',
		 $cmd_ln);
}

if ($function eq 'duo') {
    spike_duo();
}
elsif ($function eq 'trio') {
    spike_trio();
}
elsif ($function eq 'quartet1') {
    spike_quartet1();
}
elsif ($function eq 'pedigree') {
    spike_pedigree();
}
elsif ($function eq 'cohort') {
    spike_cohort();
}
elsif ($function eq 'help') {
    warn $usage;
    exit(0);
}
else {
    warn "$usage\n\n";
    send_message('FATAL',
		 'invalid_mode',
		 $function);
}

exit(0);

#-----------------------------------------------------------------------------
#-------------------------------- SUBROUTINES --------------------------------
#-----------------------------------------------------------------------------

sub parse_vcf {

    my ($file, $args) = @_;
    $args ||= {};
    my $IN;

    if (! defined $file) {
      send_message('FATAL',
		   'must_provide_vcf_file',
		   'No VCF file was provided to parse_vcf');
    }
    elsif (! -e $file) {
      send_message('FATAL',
		   'vcf_file_does_not_exist',
		   '$file');
    }
    elsif (! -r $file) {
      send_message('FATAL',
		   'vcf_file_is_not_readable',
		   $file);
    }

    if ($file =~ /\.vcf$/) {
	open ($IN, '<', $file) or
      send_message('FATAL',
		   'cant_open_file_for_reading',
		   $file);
    }
    elsif ($file =~ /\.vcf\.gz$/) {
	open($IN, '-|', "gunzip -c $file") or
      send_message('FATAL',
		   'cant_open_file_for_reading',
		   $file);
    }
    else {
      send_message('FATAL',
		   'invalid_file_extension',
		   $file);
    }

    my @meta_data;
    my $header;
    my @sample_ids;
    my @variants;

  LINE:
    while (my $line = <$IN>) {
	chomp $line;
	if ($line =~ /^\#\#/) {
	    push @meta_data, $line;
	}
	elsif ($line =~ /^\#CHROM/) {
	    $header = $line;
	    @sample_ids = split /\t/, $line;
	    splice(@sample_ids, 0, 9);
	    last LINE if $args->{headers_only};
	}
	else {
	    my ($chrom, $pos, $id, $ref, $alt, $qual, $filter,
		$info_txt, $format_txt, @gts) = split /\t/, $line;
	    $format_txt ||= '';
	    my @info_data = split /;/, $info_txt;
	    my %info;
	    for my $key_txt (@info_data) {
		my ($key, $value) = split /=/, $key_txt;
		$value = defined $value ? $value : '';
		my @values = split /,/, $value;
		push @{$info{$key}}, @values;
	    }
	    my @formats = split /:/, $format_txt;
	    my %record = ('CHROM'	=> $chrom,
			  'POS'	=> $pos,
			  'ID'		=> $id,
			  'REF'	=> $ref,
			  'ALT'	=> $alt,
			  'QUAL'	=> $qual,
			  'FILTER'	=> $filter,
			  'INFO'	=> $info_txt,
			  'FORMAT'	=> $format_txt,
			  'GTS'	=> \@gts,
			  'info_data'   => \%info,
			  'format_data' => \@formats,
		);
	    push @variants, \%record;
	}
    }
    my %vcf_data = (meta_data  => \@meta_data,
		    header     => $header,
		    variants   => \@variants,
		    sample_ids => \@sample_ids,
	);

    return \%vcf_data;
}

#-----------------------------------------------------------------------------

sub spike_duo {

    my ($x) = @_;

    warn $usage;
    send_message('FATAL',
		 'function_not_implimented',
		 'Spiking function duo is not implimented yet.');
}

#-----------------------------------------------------------------------------

sub spike_trio {

    my ($x) = @_;

    warn $usage;
    send_message('FATAL',
		 'function_not_implimented',
		 'Spiking function duo is not implimented yet.');
}

#-----------------------------------------------------------------------------

sub spike_quartet1 {

    my ($x) = @_;

    warn $usage;
    send_message('FATAL',
		 'function_not_implimented',
		 'Spiking function duo is not implimented yet.');
}

#-----------------------------------------------------------------------------

sub spike_pedigree {

    my ($x) = @_;

    warn $usage;
    send_message('FATAL',
		 'function_not_implimented',
		 'Spiking function duo is not implimented yet.');
}

#-----------------------------------------------------------------------------

sub spike_cohort {

  my $usage = "

Synopsis:

# Run cohort spiking mode with parameters defined in a config file.
spikely  spike_cohort --config_file spikely.yaml --disease_vcf clinvar.vcf.gz \
    --sample_vcf case_control.vcf.gz

Description:

The spike_cohort function will consume a VCF file of disease variants
and produce a VCF file with those variants 'spiked' into the genotypes
of a set of case & control samples defined by various genetic and
population parameters.  The script understands genetic concepts such
as inheritance, penetrance and population attributable risk and allele
population frequency and allows those parameters to be specified in a
configuration file.

Options:

--inheritance, -i

    recessive - Two causal alleles per affected individual in a given
		causal gene.
    dominant  - One causal allele per affected individual.
    x-linked - 	One causal allele on chromosome X genes per male case
    	       	individual.  Two causative alleles on chromosome X
    	       	genes per female case individual.
    additive  - Potentially many causal alleles per affected individual.

--max_rate, -r

    The max MAF for any given variant.

--par, -p

    The max percent of individuals affected with a given gene.

--penetrance, -e

    The max percent of individuals with causal alleles, but labeled in
    PED file as unaffected.

--heritability, -h

    The heritability option takes a value from 0 to 1.  This value
    determines the probability ( each individual case) that the
    individual will have disease allele(s) in one of the genes
    represented in the disease VCF file.  A higher value will give
    each case individual a higer probability of having a causative
    allele while a lower value will give each case individual a lower
    probability of having a causative allele.  This option does not
    determine which disease gene or allele an individual will recieve,
    but only if the individual will recieve any spiked disease allele.

--ped_file, -d

    The pedigree file in plink PED format.

--maf_key, -f

    The INFO key in the VCF file that contains the population MAF for
    each variant.

--gene_id_key, -g

    The INFO key in the VCF file that contains the gene symbol for
    each variant.

--config_file, -c

    The filename for a YAML formatted file that contains gene and
    variant configuration options.

";


  my $opts = {};
  my $opt_success = GetOptions($opts,
			       'help|h',
			       'mode|m=s',
			       'inheritance|i=s',
			       'max_rate|r=s',
			       'par|p=s',
			       'penetrance|e=s',
			       'heritability|h=s',
			       'ped_file|d=s',
			       'maf_key|f=s',
			       'gene_id_key|g=s',
			       'config_file|c=s',
			       'disease_vcf|x=s',
			       'sample_vcf|y=s',
			      );

  die $usage if $opts->{help} || ! $opt_success;

  # Load config file.
  my $config = {};
  $config = LoadFile($opts->{config_file}) if $opts->{config_file};

  # Load and map disease VCF file.
  warn $usage unless defined $opts->{disease_vcf};
  my $disease_vcf = parse_vcf($opts->{disease_vcf});
  my %disease_map;
  map {$disease_map{$_->{ID}} = $_} @{$disease_vcf->{variants}};

  # Load headers only from sample VCF file.
  my $sample_hdrs = parse_vcf($opts->{sample_vcf}, {headers_only => 1});
  my $sample_ids = $sample_hdrs->{sample_ids};
  my $sample_count = scalar @{$sample_ids};

  # Determine case IDs (might not be all samples);
  my @case_ids;
  if (exists $config->{case_ids}) {
    @case_ids = split /,/, $config->{case_ids};
  }
  else {
    @case_ids = @{$sample_ids};
  }
  my $case_count = scalar @case_ids;

  # Set up gene & variant data structures.
  my %gene_data;
  my %variant_data;
  my $gene_par_sum;
  my $gene_info_key;

  # Set gene_id from command line opts or...
  if (exists $opts->{gene_id_key}) {
    $gene_info_key = $opts->{gene_id_key};
    send_message('info',
		 'setting_gene_info_key',
		  $gene_info_key);
  }
  # ...from config
  elsif (exists $config->{gene_id_key}) {
    $gene_info_key = $config->{gene_id_key};
    send_message('info',
		 'setting_gene_info_key',
		  $gene_info_key);
  }
  # ...default GENEINFO (i.e. ClinVar VCF)
  else {
    $gene_info_key = 'GENEINFO';
    send_message('warn',
		 'setting_gene_info_key_to_default',
		  $gene_info_key);
  }

  for my $variant (@{$disease_vcf->{variants}}) {
    send_message('info',
		 'processing_variant',
		 $variant->{ID}
		);
    $variant_data{map}{$variant->{ID}} = $variant;

    # Get ID of gene associated with variant or set to default.
    my $gene_id;
    if (exists $variant->{info_data}{$gene_info_key}) {
      $gene_id = $variant->{info_data}{$gene_info_key}[0];
    }
    else {
      $gene_id = 'UNKNOWN_GENE';
    }

    $gene_data{$gene_id}{variant_count}++;
    push @{$gene_data{$gene_id}{variants}}, $variant;

    # Set gene inheritance from gene specific config or...
    if (exists $config->{genes}           &&
	exists $config->{genes}{$gene_id} &&
	exists $config->{genes}{$gene_id}{inheritance}) {
      $gene_data{$gene_id}{inheritance} =
	$config->{genes}{$gene_id}{inheritance};
      send_message('info',
		   'setting_gene_inheritance_from_gene_config',
		   $gene_data{$gene_id}{inheritance});
    }
    # ...from command-line opts
    elsif (exists $opts->{inheritance}) {
      $gene_data{$gene_id}{inheritance} = $opts->{inheritance};
      send_message('info',
		   'setting_gene_inheritance_from_command_line_opts',
		   $gene_data{$gene_id}{inheritance});
    }
    # ...from default config
    elsif (exists $config->{inheritance}) {
      $gene_data{$gene_id}{inheritance} = $config->{inheritance};
      send_message('info',
		   'setting_gene_inheritance_from_config_default',
		   $gene_data{$gene_id}{inheritance});
    }
    # ...default to dominant
    else {
      $gene_data{$gene_id}{inheritance} = 'dominant';
      send_message('warn',
		   'setting_gene_inheritance_to_default',
		   $gene_data{$gene_id}{inheritance});
    }

    # Set gene PAR from gene config or...
    if (exists $config->{genes}{$gene_id}{par}) {
      $gene_data{$gene_id}{par} = $config->{genes}{$gene_id}{par};
      send_message('info',
		   'setting_par_from_gene_config',
		   $gene_data{$gene_id}{par});
    }
    # ...from opts
    elsif (exists $opts->{par}) {
      $gene_data{$gene_id}{par} = $opts->{par};
      send_message('info',
		   'setting_par_from_command_line_opts',
		   $gene_data{$gene_id}{par});
    }
    # ...from default config
    elsif (exists $config->{par}) {
      $gene_data{$gene_id}{par} = $config->{par};
      send_message('info',
		   'setting_par_from_config_default',
		   $gene_data{$gene_id}{par});
    }
    # ...to default of 1.0
    else {
      $gene_data{$gene_id}{par} = 1;
      send_message('warn',
		   'setting_par_to_default',
		   $gene_data{$gene_id}{par});
    }
    my $gene_par_sum += $gene_data{$gene_id}{par};

    print '';
  }

  # Set up case data
  my $idx;
  my %case_data;
  my %spike_map;

 CASE:
  for my $case_id (@case_ids) {
    $case_data{$case_id}{idx} = $idx++;
    # Set heritability from config or default to 1.
    if (exists $config->{samples} &&
	exists $config->{samples}{$case_id} &&
	exists $config->{samples}{$case_id}{heritability}
       ) {
      $case_data{$case_id}{heritability} = $config->{samples}{$case_id}{heritability};
      send_message('info',
		   'setting_case_heritability_from_sample_config',
		   $case_data{$case_id}{heritability});
    }
    elsif (exists $opts->{heritability}) {
      $case_data{$case_id}{heritability} = $opts->{heritability};
      send_message('info',
		   'setting_case_heritability_from_command_line_opts',
		   $case_data{$case_id}{heritability});
    }
    elsif (exists $config->{heritability}) {
      $case_data{$case_id}{heritability} = $config->{heritability};
      send_message('info',
		   'setting_case_heritability_from_default_config',
		   $case_data{$case_id}{heritability});
    }
    else {
      $case_data{$case_id}{heritability} = 1 unless
	defined $case_data{$case_id}{heritability};
      send_message('warn',
		   'setting_case_heritability_to_default',
		   $case_data{$case_id}{heritability});
    }

    # Determine if sample will have a spiked genotype
    my $heritability_rnd = rand();
    if ($heritability_rnd > $case_data{$case_id}{heritability}) {
      send_message('info',
		   'heritability_skipping_sample',
		   "$case_id, $heritability_rnd, " .
		   $case_data{$case_id}{heritability});
      next CASE;
    }

    my (@genes, @pars);
    map {push @genes, $_; push @pars, $gene_data{$_}{par}}
      keys %gene_data;

    # Determine which gene a sample will be spiked with.
    my $spike_gene_id = Math::Random::Discrete->new(\@pars, \@genes)->rand;
    my $spike_gene = $gene_data{$spike_gene_id};

    my $spike_inheritance = $spike_gene->{inheritance};

    my (@variants, @mafs);
    for my $variant (@{$spike_gene->{variants}}) {
      push @variants, $variant;
      my $maf = (exists $variant->{info_data}{$config->{maf_key}} ?
		 $variant->{info_data}{$config->{maf_key}}        :
		 $spike_inheritance eq 'recessive'                ?
		 0.01                                             :
		 0.0001);
      push @mafs, $maf;
    }

    my $allele_count = $spike_inheritance eq 'dominant' ? 1 : 2;
    for my $count (1 .. $allele_count) {
      my $variant = Math::Random::Discrete->new(\@mafs, \@variants)->rand;
      my $variant_id = $variant->{ID};
      print '';
      $spike_map{$variant_id}{$case_id}++;
    }
    # $case_data{$case_id}{gene_id} = $spike_gene_id;

    print '';
  }

  print join "\n", @{$disease_vcf->{meta_data}};
  print "\n";
  print join "\t", $disease_vcf->{header}, 'FORMAT', @{$sample_ids};
  print "\n";
  for my $variant (@{$disease_vcf->{variants}}) {
    my $variant_id = $variant->{ID};
    next unless exists $spike_map{$variant_id};
    print join "\t", @{$variant}{qw(CHROM POS ID REF ALT QUAL FILTER INFO)};
    print "\tGT";
    for my $sample_id (@{$sample_ids}) {
      my $gt = (exists $spike_map{$variant_id}{$sample_id} ?
		$spike_map{$variant_id}{$sample_id}        :
		0);
      $gt = ($gt == 2 ? '1/1' :
	     $gt == 1 ? '0/1' :
	     '0/0');
      print "\t$gt";
    }
    print "\n";
    print '';
  }
  print '';

}

#-----------------------------------------------------------------------------

sub send_message {

  my ($level, $code, $message) = @_;

  if (! $level) {
    $level = 'FATAL_DEV';
    $code = 'missing_message_level';
    $message = ('Called send_message without specifying a level.  ' . 
		'Please report on https://github.com/Yandell-Lab/spikely/issues');

  }

  if (! $code) {
    $level = 'FATAL_DEV';
    $code = 'missing_message_code';
    $message = ('Called send_message without specifying a code.  ' .
		'Elevating error to FATAL.' .
		'Please report on https://github.com/Yandell-Lab/spikely/issues');
  }

  $message ||= 'No specific error message';
  chomp $message;
  $message .= "\n";

  $level = uc $level;

  if ($level eq 'INFO' || $level eq 'WARN') {
    carp join( ' : ', $level, $code, $message);
  }
  elsif ($level eq 'FATAL') {
    croak join( ' : ', $level, $code, $message);
  }
  elsif ($level eq 'FATAL_DEV') {
    confess join( ' : ', $level, $code, $message);
  }
  else {
    confess join( ' : ', 'FATAL_DEV', 'invalid_message_level', $level);
  }
}

#-----------------------------------------------------------------------------
